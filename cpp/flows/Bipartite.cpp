//Hopcroft_Karp O(EsqrtV)
struct edge
{
	int from, to, cap, flow, index;
	edge(int from, int to, int cap, int flow, int index):
		from(from), to(to), cap(cap), flow(flow), index(index) {}
};

struct Hopcroft_Karp
{
static const int inf = 1e9;

int n;
vector<int> matchL, matchR, dist;
vector<vector<int> > g;

Hopcroft_Karp(int n) :
	n(n), matchL(n+1), matchR(n+1), dist(n+1), g(n+1) {}

void addEdge(int u, int v)
{
	g[u].push_back(v);
}

bool bfs()
{
	queue<int> q;
	for(int u=1;u<=n;u++)
	{
		if(!matchL[u])
		{
			dist[u]=0;
			q.push(u);
		}
		else
			dist[u]=inf;
	}
	dist[0]=inf;

	while(!q.empty())
	{
	int u=q.front();
	q.pop();
	for(auto v:g[u])
	{
		if(dist[matchR[v]] == inf)
		{
			dist[matchR[v]] = dist[u] + 1;
			q.push(matchR[v]);
		}
	}
	}

	return (dist[0]!=inf);
}

bool dfs(int u)
{
	if(!u)
		return true;
	for(auto v:g[u])
	{
	if(dist[matchR[v]] == dist[u]+1 &&dfs(matchR[v]))
	{
		matchL[u]=v;
		matchR[v]=u;
		return true;
	}
	}
	dist[u]=inf;
	return false;
}

int max_matching()
{
	int matching=0;
	while(bfs())
	{
	for(int u=1;u<=n;u++)
	{
		if(!matchL[u])
			if(dfs(u))
				matching++;
	}
	}
	return matching;
}
};
int main(){
    Hopcroft_Karp mx(n+m+3);
	mx.addEdge(q,r);
	cout<<mx.max_matching()<<"\n";
}
